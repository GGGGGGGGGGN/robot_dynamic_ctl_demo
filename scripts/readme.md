# 控制器算法
## 1 pd test
目标是各个关节独立的pd控制器让机械臂稳定在一个位姿上，由于pd算法的原理是根据误差产生力矩，因此为了平衡重力，机械臂无法稳定的达到设置的位姿上。

## 2 ctc test
更加常用的pd控制器是重力补偿的pd控制器，该控制器在pd算的力矩上添加上了维持机械臂重力的补偿项，因此可以稳定收敛在目标的位姿上。
但是在快速运动的场景，pd控制器存在跟踪滞后和超调的问题。
如果有理想的模型，可以使用ctc的控制算法，计算关节误差和速度误差，计算一个控制加速的，并输入给动力学方程中。这个控制算法将非线性的系统线性化，并且可以证明稳定和收敛，但在这个代码中，跟踪效果并非完全理想。

## 3 ctc with friction
在ctc算法中，他的输入量是一个加速度，而非力矩，在模型理想时效果很好，但是如果存在模型失配的问题，控制效果可能还不如pd控制器。
为了解决这个问题，一般需要更加准确的模型参数。在pin导入的模型中，按照mujoco的模型文件，添加了转子的惯量和摩擦力补偿项，实现了一个非常理想的关节控制。从结果可以看到控制效果远好过pd控制器。

## 4 ctc with payload
当机械臂添加末端负载时，尤其是负载过重如5kg时，导致ctc的算法适配严重，还可能因为反馈增益被错误的放大，导致剧烈震荡偏离控制位置。
相反pd控制器虽然也有较大的控制误差，但是鲁棒性好，一直都在一定范围内实现控制。

## 5 pid ctc
给ctc添加了积分项，用于补偿当负载不变化引起的模型实配，可以看到在静止任务中，跟踪曲线上积分器让模型的误差在慢慢变小，相比于pd的ctc来讲，能取得更好的控制效果。
然而积分补偿具有滞后性，无法应用于高速的控制任务。在高速运动中，我观察到pd ctc和pid ctc都存在相同的发散风险。

## 6 MO CTC
为了实现对未知负载的控制，可以引用一个广义的动量观测器来对负载的导致的力矩变化进行观测

## 7 MO CTC sin traj
用mo跟踪一个正弦的轨迹运动，看上去跟踪效果略好于pid。 在高速的运动中，观测器存在观测滞后的效应，因此导致无法完全的跟踪上轨迹，但效果已经比不加观测器的跟踪效果好了。 另外给mo添加上关节力矩限制，符合物理约束，避免了轨迹跟踪的跟踪失败和发散问题。



🏛️ 门派一：硬碰硬的“鲁棒控制” (Robust Control)核心思想：“我不管你挂了 5kg 还是 50kg，只要你在我的物理极限内，我就用绝对的暴力把你压在轨迹上！”代表算法：滑模控制 (Sliding Mode Control, SMC)原理：设计一个“滑模面”。一旦系统因为负载偏离了轨迹，控制器就会输出极其狂暴的、非线性的正负切换力矩（比如瞬间 +100Nm，下一毫秒 -100Nm），强行把状态“砸”回轨迹上。致命缺点：抖振 (Chattering)。这种高频的暴力切换会在真机上产生恐怖的震动，分分钟把电机的减速器齿轮震得粉碎。学术界发论文最爱用，但工业界极少直接用纯滑模。🧬 门派二：自我进化的“自适应控制” (Adaptive Control)核心思想：“既然我不知道你多重，那我就一边跑一边算，用机器学习的思想把你算出来！”代表算法：模型参考自适应控制 (MRAC) 或 自适应计算力矩控制 (Adaptive CTC)原理：把动力学公式里的质量 $m$ 变成一个变量 $\hat{m}$。运行时，算法根据位置误差，利用李雅普诺夫稳定性理论实时更新 $\hat{m}$ 的值。跑着跑着，$\hat{m}$ 就会收敛到真实的 5kg。致命缺点：收敛需要时间 (Transient Error)。在算法算出真实质量的前几秒，机械臂依然会失控乱飞。如果在高速任务中，这前几秒的失控可能已经导致撞机了。🥷 门派三：见招拆招的“观测器” (Observer-based Control)核心思想：“我不去盲猜你的质量，我只看我发出的力矩和实际产生的加速度是否匹配。中间的差值，全是你这个未知负载搞的鬼！”代表算法：自抗扰控制 (ADRC) 和 扰动观测器 (DOB)。优势：这是目前兼顾了响应速度和系统安全性的最优解，工业界（尤其是高精度的直驱电机和机床）极其爱用。
